{"version":3,"file":"bundle.c6c3ecaf2fc4863d367e.js","mappings":";;;;;;;;;;;;AAAwD;;AAExD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,qEAAkB;;AAE3D;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM;AAC9C,6CAA6C,uCAAuC;AACpF,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;ACjM+T;;AAExT;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA,eAAe,gEAAe;AAC9B;AACA;;AAEA;AACA,eAAe,+DAAc;AAC7B;AACA;;AAEA;AACA,eAAe,+DAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,6DAAY;AAChC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,eAAe,+DAAc;AAC7B;AACA;;AAEA;;AAEA;;AAEA,cAAc,gEAAe;;AAE7B;AACA;AACA;AACA,oBAAoB,iEAAgB;AACpC;AACA;AACA,oBAAoB,iEAAgB;AACpC;AACA;AACA,oBAAoB,iEAAgB;AACpC;AACA;;AAEA;AACA,kBAAkB,gEAAe;AACjC;AACA;;AAEA,iCAAiC,6DAAY,aAAa,gEAAe;;AAEzE;;AAEA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;;AAEA;;AAEA,cAAc,+DAAc;AAC5B,mBAAmB;;AAEnB;AACA,iBAAiB,gEAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA,cAAc,+DAAc;;AAE5B;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,kEAAiB;AACtC,0BAA0B,wEAAuB;;AAEjD;AACA,mBAAmB,+EAA8B;AACjD;AACA;;AAEA,qBAAqB,8DAAa;AAClC,oBAAoB,4DAAW;;AAE/B;;AAEA,oBAAoB,QAAQ;AAC5B,uCAAuC,+DAAc;AACrD,iDAAiD,+DAAc;AAC/D;AACA;;AAEA;AACA,GAAG;;AAEH,qBAAqB,+DAAc;AACnC;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3MA;AACA,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD,WAAW,0CAA0C;AACrD;;AAEA;AACA,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD,WAAW,uCAAuC;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA,WAAW,sCAAsC;AACjD;;AAEA;AACA,WAAW,0CAA0C;AACrD;;;;AAIA;AACA,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7IkP;;AAElP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,yEAAwB;AAC7C,oBAAoB,yEAAwB;;AAE5C,YAAY;AACZ;;AAEA;AACA;AACA,eAAe,0EAAyB;AACxC,MAAM;AACN,eAAe,0EAAyB;AACxC,MAAM;AACN,eAAe,0EAAyB;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;;AAEA;;AAEA,WAAW,mBAAmB;;AAE9B;;AAEA,0BAA0B,+DAAc;;AAExC;;AAEA;;AAEA;;AAEA;;AAEA,yBAAyB,4EAA2B;AACpD,0BAA0B,4EAA2B;AACrD,mBAAmB,4EAA2B;AAC9C,mBAAmB,4EAA2B;;AAE9C;;AAEA;;AAEA;AACA;;AAEA;AACA,0BAA0B,+DAAc;;AAExC;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,+BAA+B;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,kEAAiB,gBAAgB,kEAAiB;AAChF;AACA,UAAU;AACV,wBAAwB,kEAAiB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,gBAAgB;;AAE9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,mEAAkB;AAC7B;;AAEA;AACA,WAAW,mEAAkB;AAC7B;;AAEO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,yEAAwB;;AAElD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,0EAAyB;AACjD;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,gBAAgB;AACxC,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7gBO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEO;AACP,KAAK,sCAAsC;AAC3C,KAAK,wCAAwC;AAC7C,KAAK,wCAAwC;AAC7C;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEO;AACP,SAAS,2DAA2D,EAAE,4DAA4D,EAAE,4DAA4D,EAAE,4DAA4D,EAAE,8DAA8D,EAAE,6DAA6D,EAAE,6DAA6D,EAAE,6DAA6D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,6DAA6D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,gEAAgE,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,kEAAkE,EAAE,iEAAiE,EAAE,kEAAkE,EAAE,iEAAiE,EAAE,kEAAkE,EAAE,kEAAkE,EAAE,gEAAgE,EAAE,kEAAkE,EAAE,kEAAkE,EAAE,kEAAkE,EAAE,kEAAkE,EAAE,kEAAkE,EAAE,kEAAkE,EAAE,kEAAkE,EAAE,kEAAkE;AAC1kF,SAAS,4DAA4D,EAAE,4DAA4D,EAAE,4DAA4D,EAAE,4DAA4D,EAAE,4DAA4D,EAAE,6DAA6D,EAAE,6DAA6D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,+DAA+D,EAAE,8DAA8D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,iEAAiE,EAAE,gEAAgE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,gEAAgE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,gEAAgE,EAAE,iEAAiE;AACxiF,SAAS,4DAA4D,EAAE,4DAA4D,EAAE,4DAA4D,EAAE,4DAA4D,EAAE,6DAA6D,EAAE,4DAA4D,EAAE,6DAA6D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,+DAA+D,EAAE,8DAA8D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,gEAAgE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE;AAC1iF,SAAS,0DAA0D,EAAE,4DAA4D,EAAE,4DAA4D,EAAE,2DAA2D,EAAE,6DAA6D,EAAE,4DAA4D,EAAE,6DAA6D,EAAE,6DAA6D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,+DAA+D,EAAE,gEAAgE,EAAE,+DAA+D,EAAE,8DAA8D,EAAE,gEAAgE,EAAE,+DAA+D,EAAE,gEAAgE,EAAE,+DAA+D,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,+DAA+D,EAAE,gEAAgE,EAAE,gEAAgE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE,EAAE,iEAAiE;AACtiF;;AAEO;AACP,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC;AACA;AACA;;AAEO;;AAEA;;AAEA;AACP;AACA;AACA;AACA;AACA;;AAEO;;;;;;;;;;;;;ACxF2D;AACK;;AAEvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,eAAe,EAAE,gEAAa;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,gEAAa;;AAErC,wBAAwB,+BAA+B;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,YAAY;AACpC,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA,cAAc;AACd,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,kFAAiC;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,6BAA6B;AAC1D,iCAAiC,yCAAyC;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;UChWA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACN2B","sources":["webpack://dami-ui/./src/barcode/barcode.js","webpack://dami-ui/./src/barcode/encoding-service.js","webpack://dami-ui/./src/barcode/encoding-structure.js","webpack://dami-ui/./src/qrcode/encoding-service.js","webpack://dami-ui/./src/qrcode/encoding-structure.js","webpack://dami-ui/./src/qrcode/qrcode.js","webpack://dami-ui/webpack/bootstrap","webpack://dami-ui/webpack/runtime/define property getters","webpack://dami-ui/webpack/runtime/hasOwnProperty shorthand","webpack://dami-ui/webpack/runtime/make namespace object","webpack://dami-ui/./src/index.js"],"sourcesContent":["import { chooseEncodingType } from \"./encoding-service\";\n\nconst svgns = \"http://www.w3.org/2000/svg\";\n\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n    <style>\n        svg {\n            border: solid 1px rgba(0, 0, 0, 0.2);\n            border-radius: 10px;\n        }\n    </style>\n    <svg xmlns=\"${svgns}\"></svg>\n`\n\nclass DamiBarcode extends HTMLElement {\n    constructor() {\n        super();\n        this.initShadow();\n\n        this.xyPadding = 10;\n\n        this.width = 300;\n        this.height = 300 / 3;\n        this.color = \"black\";\n        this.background = \"white\";\n        this.font = \"Consolas, Monaco, Sans Mono, monospace, sans-serif\";\n    }\n\n    initShadow() {\n        const shadow = this.attachShadow({mode: \"open\"});\n        shadow.append(template.content.cloneNode(true));\n        this.svgElm = shadow.querySelector(\"svg\");\n    }\n\n    initSvgSize() {\n        const width = this.getAttribute(\"width\") ? Number(this.getAttribute(\"width\")) : this.width;\n        const height = this.getAttribute(\"height\") ? Number(this.getAttribute(\"height\")) : Math.trunc(width / 3);\n\n        if (typeof width === \"number\" && typeof height === \"number\") {\n            this.svgElm.setAttribute(\"width\", width);\n            this.svgElm.setAttribute(\"height\", height);\n        } else {\n            console.error(\"Enter both width and height and all numbers.\");\n        }\n    }\n\n    initRectWithSize(x, y, width, height, color) {\n        const rectElm = document.createElementNS(svgns, \"rect\");\n\n        rectElm.setAttribute(\"width\", width);\n        rectElm.setAttribute(\"height\", height);\n\n        rectElm.setAttribute(\"x\", x);\n        rectElm.setAttribute(\"y\", y);\n        \n        rectElm.setAttribute(\"fill\", color);\n\n        return rectElm;\n    }\n\n    connectedCallback() {\n        this.initSvgSize();\n\n        const background = this.getAttribute(\"background\") ? this.getAttribute(\"background\") : this.background;\n        this.svgElm.style.background = background;\n\n        this.drawBarcode();\n    }\n\n    static get observedAttributes() {\n        return [\"width\", \"height\", \"type\", \"value\", \"color\", \"background\"];\n    }\n    \n    attributeChangedCallback(name, oldValue, newValue) {\n        \n    }\n\n    drawBarcode() {\n        if (this.getAttribute(\"type\") && this.getAttribute(\"value\")) {\n            const encodingValAndChksum = chooseEncodingType(this.getAttribute(\"type\"), this.getAttribute(\"value\"));\n\n            const value = !this.hasAttribute(\"no-text\") ? this.getAttribute(\"value\") : \"\";\n            const checksum = !this.hasAttribute(\"no-checksum\") && !this.hasAttribute(\"no-text\") ? encodingValAndChksum?.[1] : \"\";\n\n            if (!encodingValAndChksum || !encodingValAndChksum?.[0]) return;\n\n            this.fillRectBlocks(encodingValAndChksum[0]);\n            this.createTextCenterBottom(value, checksum);\n        } else {\n            console.error(\"Properly enter type and value property for barcode.\");\n        }\n    }\n\n    fillRectBlocks(codeValue) {\n        const rectDimention = this.getRectDimentions(codeValue.length);\n        const startPos = this.getRectStartPos();\n\n        const rectBlocks = this.makeRectBlocks(codeValue);\n\n        const color = this.getAttribute(\"color\") ? this.getAttribute(\"color\") : this.color;\n        const background = this.getAttribute(\"background\") ? this.getAttribute(\"background\") : this.background;\n\n        let swt = true;\n\n        rectBlocks.forEach(blockLen => {\n            const width = rectDimention[0] * blockLen;\n            const height = rectDimention[1];\n\n            const startX = startPos[0];\n            const startY = startPos[1];\n\n            const rectElm = this.initRectWithSize(startX, startY, width, height, swt ? color : background);\n            this.svgElm.appendChild(rectElm);\n\n            startPos[0] += width;\n\n            swt = !swt;\n        });\n    }\n\n    makeRectBlocks(codeValue) {\n        let checkVal = null;\n        const blockAry = [];\n\n        codeValue.split(\"\").forEach(code => {\n            if (checkVal !== code) {\n                checkVal = code;\n                blockAry.push(1);\n            } else {\n                blockAry[blockAry.length - 1]++;\n            }\n        });\n\n        return blockAry;\n    }\n\n    getSvgDimentions() {\n        const width = this.svgElm?.clientWidth;\n        const height = this.svgElm?.clientHeight;\n    \n        if (width === undefined || height === undefined) return;\n        return [width, height];\n    }\n\n    getRectDimentions(noOfRect) {\n        const xPaddingPct = this.xyPadding * 2;\n        const yPaddingPct = this.xyPadding * 2 * 2;\n    \n        const svgDimentions = this.getSvgDimentions();\n    \n        if (!svgDimentions) return;\n    \n        const contWidth = ( (100 - xPaddingPct) * svgDimentions[0] ) / 100;\n        const contHeight = ( (100 - yPaddingPct) * svgDimentions[1] ) / 100;\n    \n        return [contWidth / noOfRect, contHeight];\n    }\n\n    getRectStartPos() {\n        const svgDimentions = this.getSvgDimentions();\n    \n        if (!svgDimentions) return;\n    \n        return [( this.xyPadding * svgDimentions[0] / 100),\n                ( this.xyPadding * svgDimentions[1] ) / 100];\n    }\n\n    createTextCenterBottom(value, checksum) {\n        const textElm = document.createElementNS(svgns, \"text\");\n\n\n\n        const color = this.getAttribute(\"color\") ? this.getAttribute(\"color\") : this.color;\n        const font = this.getAttribute(\"font\") ? this.getAttribute(\"font\") : this.font;\n\n        textElm.setAttribute(\"text-anchor\", \"middle\");\n        textElm.setAttribute(\"dominant-baseline\", \"middle\");\n    \n        textElm.setAttribute(\"x\", \"50%\");\n        textElm.setAttribute(\"y\", \"90%\");\n        textElm.setAttribute(\"fill\", `${color}`);\n        textElm.setAttribute(\"font-size\", `${0.05 * (this.svgElm?.clientWidth ?? 0)}`);\n        textElm.setAttribute(\"font-family\", `${font}`);\n        \n        var textNode = document.createTextNode(value.trim() + checksum.trim());\n        textElm.appendChild(textNode);\n    \n        this.svgElm.appendChild(textElm);\n    }\n\n}\n\ncustomElements.define(\"dami-barcode\", DamiBarcode);\n","import { CODE11_ENCODING, CODE11_MARKERS, EAN13_STRUCTURE, EAN8_STRUCTURE, EAN_UPC_ENCODING, EAN_UPC_MARKERS, UPCA_STRUCTURE, UPCE_MARKERS, UPCE_PATTERN, UPCE_STRUCTURE, CODE39_CHARACTERS, CODE39_BARS, CODE39_SPACES, CODE39_MARKERS, CODE39_OTHER_CHARACTERS, CODE39_OTHER_CHARACTERS_ENCODE } from './encoding-structure';\n\nexport function calcChecksumEanUpc(value) {\n    let sum = 0;\n    for (const [index, digit] of value.split(\"\").reverse().entries()) {\n      if (index % 2 <= 0) {\n        sum += (Number(digit) * 3);    \n      } else {\n        sum += (Number(digit) * 1);   \n      }\n    }\n\n    return (10 - (sum % 10)) > 9 ? \"0\" : (10 - (sum % 10)).toString();\n}\n\nexport function eanUpcEncoder(value, type) {\n    let struct;\n    if (type === \"EAN13\") {\n      struct = EAN13_STRUCTURE.get(value[0]);\n      value = value.slice(1) + calcChecksumEanUpc(value);\n    }\n\n    if (type === \"EAN8\") {\n      struct = EAN8_STRUCTURE.get(\"0\");\n      value = value + calcChecksumEanUpc(value);\n    }\n\n    if (type === \"UPCA\") {\n      struct = UPCA_STRUCTURE.get(\"0\");\n      value = value + calcChecksumEanUpc(value);\n    }\n\n    if (type === \"UPCE\") {\n      let lastDigit = value[value.length - 1];\n      let valAry = value.split(\"\").reverse();\n      let pattern = UPCE_PATTERN.get(lastDigit);\n      if (!pattern) return;\n      let upcaEquv = pattern.split(\"\").map(chr => {\n        if (chr === \"X\") return valAry.pop();\n        return chr;\n      }).join(\"\");\n      let checksum = calcChecksumEanUpc(upcaEquv);\n      struct = UPCE_STRUCTURE.get(checksum);\n      struct.lastGroup = \"\";\n    }\n\n    if (!struct) return;\n\n    let encode = \"\";\n\n    encode += EAN_UPC_MARKERS.startMarker;\n\n    for (const [index, str] of (struct.firstGroup + struct.lastGroup).split(\"\").entries()) {\n      switch (str) {\n        case \"L\":\n          encode += EAN_UPC_ENCODING.get(value[index])?.lCode;\n          break;\n        case \"G\":\n          encode += EAN_UPC_ENCODING.get(value[index])?.gCode;\n          break;\n        case \"R\":\n          encode += EAN_UPC_ENCODING.get(value[index])?.rCode;\n          break;\n      }\n\n      if (type !== \"UPCE\" && index === struct.firstGroup.length - 1) {\n        encode += EAN_UPC_MARKERS.centerMarker;\n      }\n    }\n\n    encode += (type === \"UPCE\" ? UPCE_MARKERS.endMarker : EAN_UPC_MARKERS.endMarker);\n\n    return encode;\n\n}\n\nexport function calcChecksumCode11(value) {\n    let sum = 0;\n    const ck = [\"\", \"\"];\n    const divideBy = [10, 9];\n\n    let calcK = value.length > 10 ? 2 : 1;\n\n    for (let i = 0; i < calcK; i++) {\n      for (const [index, digit] of value.split(\"\").reverse().entries()) {\n        const mul = (index + 1) % divideBy[i] <= 0 ? divideBy[i] : (index + 1) % divideBy[i];\n        const num = digit === \"-\" ? 10 : Number(digit);\n  \n        sum += (num * mul);\n      }\n      ck[i] = (sum % 11).toString();\n  \n      value += ck[i];\n      sum = 0;\n    }\n\n    return ck.join(\"\");\n    \n}\n\nexport function code11Encoder(value) {\n    value = value + calcChecksumEanUpc(value);\n\n    let encode = \"\";\n\n    encode += CODE11_MARKERS.startMarker;\n    encode += \"0\"; // Gap between codes\n\n    for (const chr of value) {\n      let code = CODE11_ENCODING.get(chr);\n      if (code) {\n        encode += code;\n        encode += \"0\";\n      }\n    }\n\n    encode += CODE11_MARKERS.endMarker;\n\n    return encode;\n}\n\nexport function code39Encoder(value) {\n  const charList = value.split(\"\");\n  charList.push(\"*\");\n  charList.unshift(\"*\");\n\n  const encode = [];\n\n  charList.forEach(chr => {\n    const chrIndex = CODE39_CHARACTERS.indexOf(chr);\n    const otherChrIndex = CODE39_OTHER_CHARACTERS.indexOf(chr);\n\n    if (chrIndex < 0 && otherChrIndex >= 0) {\n      encode.push( CODE39_OTHER_CHARACTERS_ENCODE.get(chr) );\n      return;\n    }\n\n    const spacePos = CODE39_SPACES[ Math.trunc( chrIndex / 10 ) ];\n    const barsPos = CODE39_BARS[ chrIndex % 10 ];\n\n    const chrCode = [];\n\n    for (let i = 1; i < 10; i++) {\n      if (spacePos === i) chrCode.push(CODE39_MARKERS.space);\n      else if (barsPos.includes(i)) chrCode.push(CODE39_MARKERS.bar);\n      else chrCode.push(i % 2);\n    }\n\n    encode.push( chrCode.join(\"\") );\n  });\n\n  return encode.join(CODE39_MARKERS.narrowSpace);\n}\n\n\nexport function chooseEncodingType(type, value) {\n    switch(type?.toUpperCase()) {\n      case \"EAN13\":\n        if (value.length !== 12 || !( /^\\d+$/.test(value) )) {\n          console.error(\"Dami UI barcode: number of symbols needed is 12 and all digits.\");\n          break;\n        }\n        return [eanUpcEncoder(value, type.toUpperCase()), calcChecksumEanUpc(value)];\n\n      case \"EAN8\":\n        if (value.length !== 7 || !( /^\\d+$/.test(value) )) {\n          console.error(\"Dami UI barcode: number of symbols needed is 7 and all digits.\");\n          break;\n        }\n        return [eanUpcEncoder(value, type.toUpperCase()), calcChecksumEanUpc(value)];\n\n      case \"UPCA\":\n        if (value.length !== 11 || !( /^\\d+$/.test(value) )) {\n          console.error(\"Dami UI barcode: number of symbols needed is 11 and all digits.\");\n          break;\n        }\n        return [eanUpcEncoder(value, type.toUpperCase()), calcChecksumEanUpc(value)];\n\n      case \"UPCE\":\n        if (value.length !== 6 || !( /^\\d+$/.test(value) )) {\n          console.error(\"Dami UI barcode: number of symbols needed is 6 and all digits.\");\n          break;\n        }\n        return [eanUpcEncoder(value, type.toUpperCase()), calcChecksumEanUpc(value)];\n\n      case \"CODE11\":\n        if (!( /^(\\d|-)+$/.test(value) )) {\n          console.error(\"Dami UI barcode: should contain digit and/or hyphen(-).\");\n          break;\n        }\n        return [code11Encoder(value), calcChecksumCode11(value)];\n\n      case \"CODE39\":\n        if (!( /^[A-Z0-9 \\-.\\$\\/\\+\\%]*$/.test(value) )) {\n          console.error(\"Dami UI barcode: should contain digits, capital alphapetic character, '-', '.', '[space]', '$', '/', '+', '%'.\");\n          break;\n        }\n        return [code39Encoder(value), \"\"];\n\n      default:\n        console.error(`Dami UI barcode: Give proper barcode type for encoding.`);\n        break;\n    }\n}\n","const EAN13_STRUCTURE = new Map([\n    [\"0\", {firstGroup: \"LLLLLL\", lastGroup: \"RRRRRR\"}],\n    [\"1\", {firstGroup: \"LLGLGG\", lastGroup: \"RRRRRR\"}],\n    [\"2\", {firstGroup: \"LLGGLG\", lastGroup: \"RRRRRR\"}],\n    [\"3\", {firstGroup: \"LLGGGL\", lastGroup: \"RRRRRR\"}],\n    [\"4\", {firstGroup: \"LGLLGG\", lastGroup: \"RRRRRR\"}],\n    [\"5\", {firstGroup: \"LGGLLG\", lastGroup: \"RRRRRR\"}],\n    [\"6\", {firstGroup: \"LGGGLL\", lastGroup: \"RRRRRR\"}],\n    [\"7\", {firstGroup: \"LGLGLG\", lastGroup: \"RRRRRR\"}],\n    [\"8\", {firstGroup: \"LGLGGL\", lastGroup: \"RRRRRR\"}],\n    [\"9\", {firstGroup: \"LGGLGL\", lastGroup: \"RRRRRR\"}],\n]);\n\nconst EAN_UPC_ENCODING = new Map([\n    [\"0\", {lCode: \"0001101\", gCode: \"\", rCode: \"\"}],\n    [\"1\", {lCode: \"0011001\", gCode: \"\", rCode: \"\"}],\n    [\"2\", {lCode: \"0010011\", gCode: \"\", rCode: \"\"}],\n    [\"3\", {lCode: \"0111101\", gCode: \"\", rCode: \"\"}],\n    [\"4\", {lCode: \"0100011\", gCode: \"\", rCode: \"\"}],\n    [\"5\", {lCode: \"0110001\", gCode: \"\", rCode: \"\"}],\n    [\"6\", {lCode: \"0101111\", gCode: \"\", rCode: \"\"}],\n    [\"7\", {lCode: \"0111011\", gCode: \"\", rCode: \"\"}],\n    [\"8\", {lCode: \"0110111\", gCode: \"\", rCode: \"\"}],\n    [\"9\", {lCode: \"0001011\", gCode: \"\", rCode: \"\"}],\n]);\n\nconst EAN_UPC_MARKERS = {\n    startMarker: \"101\",\n    centerMarker: \"01010\",\n    endMarker: \"101\",\n};\n\nfor (const obj of EAN_UPC_ENCODING.values()) {\n    obj.rCode = obj.lCode.\n                    trim().\n                    split(\"\").\n                    map(chr => chr === \"0\" ? \"1\" : \"0\").\n                    join(\"\");\n\n    obj.gCode = obj.rCode.\n                trim().split(\"\").reverse().join(\"\");\n}\n\n\n\n\nconst EAN8_STRUCTURE = new Map([\n    [\"0\", {firstGroup: \"LLLL\", lastGroup: \"RRRR\"}],\n]);\n\nconst UPCA_STRUCTURE = new Map([\n    [\"0\", {firstGroup: \"LLLLLL\", lastGroup: \"RRRRRR\"}],\n]);\n\n\n\nconst UPCE_STRUCTURE = new Map([\n    [\"0\", {firstGroup: \"GGGLLL\"}],\n    [\"1\", {firstGroup: \"GGLGLL\"}],\n    [\"2\", {firstGroup: \"GGLLGL\"}],\n    [\"3\", {firstGroup: \"GGLLLG\"}],\n    [\"4\", {firstGroup: \"GLGGLL\"}],\n    [\"5\", {firstGroup: \"GLLGGL\"}],\n    [\"6\", {firstGroup: \"GLLLGG\"}],\n    [\"7\", {firstGroup: \"GLGLGL\"}],\n    [\"8\", {firstGroup: \"GLGLLG\"}],\n    [\"9\", {firstGroup: \"GLLGLG\"}],\n]);\n\nconst UPCE_PATTERN = new Map([\n    [\"0\", \"0XX00000XXX\"],\n    [\"1\", \"0XX10000XXX\"],\n    [\"2\", \"0XX20000XXX\"],\n    [\"3\", \"0XXX00000XX\"],\n    [\"4\", \"0XXXX00000X\"],\n    [\"5\", \"0XXXXX00005\"],\n    [\"6\", \"0XXXXX00006\"],\n    [\"7\", \"0XXXXX00007\"],\n    [\"8\", \"0XXXXX00008\"],\n    [\"9\", \"0XXXXX00009\"],\n]);\n\nconst UPCE_MARKERS = {\n    endMarker: \"010101\",\n};\n\n\nconst CODE11_ENCODING = new Map([\n    [\"0\",  \"101011\"],\n    [\"1\",  \"1101011\"],\n    [\"2\",  \"1001011\"],\n    [\"3\",  \"1100101\"],\n    [\"4\",  \"1011011\"],\n    [\"5\",  \"1101101\"],\n    [\"6\",  \"1001101\"],\n    [\"7\",  \"1010011\"],\n    [\"8\",  \"1101001\"],\n    [\"9\",  \"110101\"],\n    [\"-\",  \"101101\"],\n]);\n\nconst CODE11_MARKERS = {\n    startMarker: \"1011001\",\n    endMarker: \"1011001\",\n};\n\nconst CODE39_CHARACTERS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *\";\n\nconst CODE39_OTHER_CHARACTERS = \"$/+%\";\n\nconst CODE39_OTHER_CHARACTERS_ENCODE = new Map([\n    [\"$\", \"100100100101\"],\n    [\"/\", \"100100101001\"],\n    [\"+\", \"100101001001\"],\n    [\"%\", \"101001001001\"],\n]);\n\nconst CODE39_BARS = [\n    [1, 9],\n    [3, 9],\n    [1, 3],\n    [5, 9],\n    [1, 5],\n    [3, 5],\n    [7, 9],\n    [1, 7],\n    [3, 7],\n    [5, 7],\n]\n\nconst CODE39_SPACES = [\n    4,\n    6,\n    8,\n    2,\n]\n\nconst CODE39_MARKERS = {\n    bar: \"11\",\n    space: \"00\",\n    narrowSpace: \"0\",\n};\n\nexport {\n    EAN13_STRUCTURE,\n    EAN_UPC_ENCODING,\n    EAN_UPC_MARKERS,\n    EAN8_STRUCTURE,\n    UPCA_STRUCTURE,\n    UPCE_STRUCTURE,\n    UPCE_PATTERN,\n    UPCE_MARKERS,\n    CODE11_ENCODING,\n    CODE11_MARKERS,\n    CODE39_CHARACTERS,\n    CODE39_BARS,\n    CODE39_SPACES,\n    CODE39_MARKERS,\n    CODE39_OTHER_CHARACTERS,\n    CODE39_OTHER_CHARACTERS_ENCODE\n}","import {Character_Capacity_Table, Character_Count_Indicator, Mode_Indicator, Alphanumeric_Code, Error_Correction_Code_Table, Galois_Field_Table, Remainder_Bits, Format_Information_Table, Version_Information_Table} from \"./encoding-structure\";\n\nfunction getQrMode(value) {\n    if (typeof value !== \"string\" || value === \"\") {\n        console.error(\"Dami-UI Qrcode: The value must be a non-empty string.\");\n        return;\n    } else if (!(/\\D/.test(value))) {\n        return \"numeric\";\n    } else if (/^[A-Z0-9 -\\.\\$\\/\\+\\%\\:\\*]*$/.test(value)) {\n        return \"alphanumeric\";\n    } else {\n        return \"byte\";\n    }\n}\n\nfunction getCodeCapacityAndVersion(value, modeType, correctionLevel) {\n    const charLength = utf8Length(value);\n\n    const capacity = Character_Capacity_Table[modeType][correctionLevel].find(val => val >= charLength);\n    const version = Character_Capacity_Table[modeType][correctionLevel].indexOf(capacity) + 1;\n\n    return {capacity, version};\n}\n\nfunction characterCountSize(version, modeType) {\n    if (version <= 9) {\n        return Character_Count_Indicator[0][modeType];\n    } else if (version <= 26) {\n        return Character_Count_Indicator[1][modeType];\n    } else {\n        return Character_Count_Indicator[2][modeType];\n    }\n}\n\nfunction getCharacterCountIndicator(value, version, modeType) {\n    const charLength = utf8Length(value);\n    const charCountLength = characterCountSize(version, modeType);\n\n    const charLenInBinary = charLength.toString(2).split(\"\");\n\n    while (charLenInBinary.length < charCountLength) {\n        charLenInBinary.unshift(\"0\");\n    }\n\n    return charLenInBinary.join(\"\");\n}\n\nexport function qrEncodedData(value, correctionLevel) {\n    const modeType = getQrMode(value);\n\n    if (!modeType) return;\n\n    const {capacity, version} = getCodeCapacityAndVersion(value, modeType, correctionLevel);\n\n    if (!capacity || !version) return;\n\n    const modeIndicator = Mode_Indicator.get(modeType);\n\n    const characterCountIndicator = getCharacterCountIndicator(value, version, modeType);\n\n    const encodedData = encodeData(value, modeType);\n\n    if (!modeIndicator || !characterCountIndicator || !encodedData) return;\n\n    const dataAry = [modeIndicator, characterCountIndicator, encodedData];\n\n    const dataCapacity = Error_Correction_Code_Table[correctionLevel][version - 1].dataCapacity;\n    const errorPerBlock = Error_Correction_Code_Table[correctionLevel][version - 1].errorPerBlock;\n    const group1 = Error_Correction_Code_Table[correctionLevel][version - 1].group1;\n    const group2 = Error_Correction_Code_Table[correctionLevel][version - 1].group2;\n\n    if (!dataCapacity || !errorPerBlock) return;\n\n    const encodedAry = encodedDataWithPaddings(dataAry, dataCapacity);\n\n    const codeBlocks = getAllCodeBlocks(encodedAry, group1, group2);\n    const errorBlocks = getAllErrorCorectionCode(errorPerBlock, codeBlocks);\n\n    const encodedDataWithErrorCorrection = interleaveDataBlocks(codeBlocks) + interleaveDataBlocks(errorBlocks);\n    const remainderBits = Remainder_Bits[version - 1];\n\n    const finalEncodedData = encodedDataWithErrorCorrection.padEnd(encodedDataWithErrorCorrection.length + remainderBits, \"0\");\n\n    return {data: finalEncodedData, version: version};\n}\n\nfunction encodedDataWithPaddings(dataAry, capacity) {\n    let dataBits = dataAry.flat().join(\"\");\n    const capacityBitLen = capacity * 8;\n    const encodedAry = [];\n\n    if (capacityBitLen - dataBits.length >= 4) dataBits = dataBits.padEnd(dataBits.length + 4, \"0\");\n    else dataBits = dataBits.padEnd(capacityBitLen, \"0\");\n    \n    if (dataBits.length % 8 > 0) dataBits = dataBits.padEnd((Math.trunc(dataBits.length / 8) + 1) * 8, \"0\");\n\n    let i = 0;\n    while ((capacityBitLen / 8) > (dataBits.length / 8)) {\n        const padBytes = [\"11101100\", \"00010001\"];\n        dataBits = dataBits + padBytes[i % 2];\n        i++;\n    }\n\n    for (let start = 0; start < (dataBits.length / 8); start++) {\n        encodedAry.push( dataBits.slice(start * 8, (start + 1) * 8) );\n    }\n\n    return encodedAry;\n}\n\nfunction encodeData(value, modeType) {\n    if (modeType === \"numeric\") {\n        return encodeNumericData(value);\n    } else if (modeType === \"alphanumeric\") {\n        return encodeAlphanumericData(value);\n    } else if (modeType === \"byte\") {\n        return encodeByteData(value);\n    } else {\n        return;\n    }\n}\n\nfunction encodeNumericData(value) {\n    const numChunk = [];\n    const valAry = value.split(\"\");\n    const binaryAry = []\n\n    while (valAry.length > 3) {\n        numChunk.push( Number(valAry.splice(0, 3).join(\"\")) );\n    }\n    numChunk.push( Number(valAry.join(\"\")) );\n\n    numChunk.forEach(num => {\n        const numLen = digitLength(num);\n        let binaryForm = num.toString(2);\n\n        if (numLen === 3) {\n            binaryAry.push( binaryForm.padStart(10, \"0\") );\n        }\n        if (numLen === 2) {\n            binaryAry.push( binaryForm.padStart(7, \"0\") );\n        }\n        if (numLen === 1) {\n            binaryAry.push( binaryForm.padStart(4, \"0\") );\n        }\n    });\n\n    return binaryAry;\n}\n\nfunction digitLength(num) {\n    let count = 1;\n    while ( Math.trunc(num / 10) > 0 ) {\n        num = Math.trunc(num / 10);\n        count++\n    }\n\n    return count;\n}\n\nfunction utf8Length(value) {\n    const utf8Str = encodeURIComponent(value);\n    const hexNum = utf8Str.split(\"\").filter(chr => chr === \"%\").length;\n    return utf8Str.length - (2 * hexNum);\n}\n\nfunction encodeAlphanumericData(value) {\n    const letterChunk = [];\n    const valAry = value.split(\"\");\n    const binaryAry = []\n\n    while (valAry.length > 2) {\n        letterChunk.push( valAry.splice(0, 2).join(\"\") );\n    }\n    letterChunk.push( valAry.join(\"\") );\n\n    letterChunk.forEach(str => {\n        let binaryForm;\n        if (str.length === 2) {\n            const num = (45 * Alphanumeric_Code.get(str[0])) + Alphanumeric_Code.get(str[1]);\n            binaryForm = num.toString(2);\n        } else {\n            const num = Alphanumeric_Code.get(str[0]);\n            binaryForm = num.toString(2);\n        }\n\n        if (str.length === 2) {\n            binaryAry.push( binaryForm.padStart(11, \"0\") );\n        }\n        if (str.length === 1) {\n            binaryAry.push( binaryForm.padStart(6, \"0\") );\n        }\n    });\n\n    return binaryAry;\n}\n\nfunction encodeByteData(value) {\n    const utf8Str = encodeURIComponent(value);\n    const binaryAry = [];\n\n    let hex = 0;\n    for (let i = 0; i < utf8Str.length; i++) {\n        if (utf8Str[i] === \"%\") {\n            let binaryVal = parseInt(utf8Str[i+1] + utf8Str[i+2], 16).toString(2).padStart(8, '0');\n            binaryAry.push(binaryVal);\n            hex = 2;\n            continue;\n        }\n        if (hex > 0) {\n            hex--;\n            continue;\n        }\n\n        binaryAry.push( utf8Str[i].charCodeAt(0).toString(2).padStart(8, \"0\") );\n    }\n\n    return binaryAry;\n}\n\n\n// Error Correct Code\n\nfunction interleaveDataBlocks(dataBlocks) {\n    const interleavedData = [];\n    const maxLen = Math.max(...dataBlocks.map(block => block.length));\n\n    for (let i = 0; i < maxLen; i++) {\n        for (const block of dataBlocks) {\n            const bin = block[i];\n            if (bin !== undefined && bin !== null) interleavedData.push(bin);\n        }\n    }\n\n    return interleavedData.join(\"\");\n}\n\nfunction getAllCodeBlocks(encodedData, group1, group2) {\n    let start = 0;\n    let codeBlocks = [];\n\n    for (let i = 0; i < group1[0]; i++) {\n        const block = encodedData.slice(start, start + group1[1]);\n        codeBlocks.push(block);\n        start += group1[1];\n    }\n\n    for (let i = 0; i < group2[0]; i++) {\n        const block = encodedData.slice(start, start + group2[1]);\n        codeBlocks.push(block);\n        start += group2[1];\n    }\n\n    return codeBlocks\n}\n\nfunction getAllErrorCorectionCode(errorCodeware, codeBlocks) {\n    const errorBlocks = [];\n\n    for (const code of codeBlocks) {\n        errorBlocks.push( errorCorrectioCodeGen(errorCodeware, code) );\n    }\n\n    return errorBlocks;\n}\n\nfunction errorCorrectioCodeGen(errorCodeware, encodedData) {\n    const messagePoly = encodedData.map((bin, i) => [parseInt(bin, 2), encodedData.length - 1 - i + errorCodeware]);\n    let generatorPoly = GeneratorPolynomial(errorCodeware);\n\n    const xAddTerm = messagePoly[0][1] - generatorPoly[0][1];\n    generatorPoly = generatorPoly.map(ary => [ary[0], ary[1] + xAddTerm]);\n\n    const remainder = polyDivisionRecur(messagePoly.map(ary => ary[0]), generatorPoly.map(ary => ary[0]), messagePoly.length);\n    \n    return remainder.map(int => int.toString(2).padStart(8, \"0\"));\n}\n\nfunction polyDivisionRecur(message, generator, steps) {\n    if (steps <= 0) return message;\n\n    const mulExp = findExp(message[0]);\n\n    const newGenerator = generator.map(exp => findInt(exp + mulExp > 255 ? (exp + mulExp) % 255 : (exp + mulExp)));\n    \n    message = message.length > newGenerator.length ? message.map((msg, ind) => msg ^ (newGenerator[ind] ?? 0)) : newGenerator.map((msg, ind) => msg ^ (message[ind] ?? 0));\n\n    let i = 0;\n    while (message[0] === 0) {message.shift();i++;}\n\n    return polyDivisionRecur(message, generator, steps - i);\n}\n\nfunction GeneratorPolynomial(codeware, n1 = [[0,1],[0,0]], n2 = [[0,1],[1,0]]) {\n    if (n2[1][0] >= codeware) return n1;\n\n    const result = [];\n    let newN1 = [];\n    for (let n1i of n1) {\n        for (let n2i of n2) {\n            const a = (n1i[0] + n2i[0]) > 255 ? (n1i[0] + n2i[0]) % 255 : (n1i[0] + n2i[0]);\n            const x = n1i[1] + n2i[1];\n            newN1.push([a, x]);\n        }\n    }\n\n    while (newN1.length > 0) {\n        const likeTerms = newN1.filter(trm => trm[1] === newN1[0][1]);\n        const unlikeTerms = newN1.filter(trm => trm[1] !== newN1[0][1]);\n        let addXor = likeTerms.map(trm => trm[0]).reduce((acc, val) => acc ^ findInt(val), 0);\n        addXor === 0 ? null : result.push([findExp(addXor), newN1[0][1]]);\n        newN1 = unlikeTerms;\n    }\n\n    n2[1][0] = n2[1][0] + 1;\n    return GeneratorPolynomial(codeware, result, n2);\n}\n\nfunction findInt(exp) {\n    return Galois_Field_Table.find(val => val.exp === exp).int;\n}\n\nfunction findExp(int) {\n    return Galois_Field_Table.find(val => val.int === int).exp;\n}\n\nexport function getFinalQrAry(qrAry, qrSize, dataIds, correctionLevel, version) {\n    const qrArysWithFormatAndVersionInfo = getQrArysWithFormatAndVersionInfo([...qrAry], qrSize, correctionLevel, version);\n    const maskedQrArys = getMaskedQrArys(qrArysWithFormatAndVersionInfo, dataIds, qrSize);\n    const qrAryWithMinPenalty = getQrAryWithMinPenalty(maskedQrArys, qrSize);\n\n    return qrAryWithMinPenalty;\n}\n\nfunction getQrArysWithFormatAndVersionInfo(qrAry, qrSize, correctionLevel, version) {\n    const qrArysWithInfo = [];\n    getQrArysWithFormatInfo(qrAry, qrSize, correctionLevel, qrArysWithInfo);\n    getQrArysWithVersionInfo(qrSize, version, qrArysWithInfo);\n\n    return qrArysWithInfo;\n}\n\nfunction getQrArysWithFormatInfo(qrAry, qrSize, correctionLevel, qrArysWithInfo) {\n    const formatBitsAry = Format_Information_Table[correctionLevel];\n\n    const versionId0 = [0 + qrSize * 8, 1 + qrSize * 8, 2 + qrSize * 8, 3 + qrSize * 8, 4 + qrSize * 8, 5 + qrSize * 8, 7 + qrSize * 8, 8 + qrSize * 8, 8 + qrSize * 7, 8 + qrSize * 5, 8 + qrSize * 4, 8 + qrSize * 3, 8 + qrSize * 2, 8 + qrSize * 1, 8 + qrSize * 0,]\n    const versionId1 = [null, null, null, null, null, null, null, qrSize - 8 + qrSize * 8, qrSize - 7 + qrSize * 8, qrSize - 6 + qrSize * 8, qrSize - 5 + qrSize * 8, qrSize - 4 + qrSize * 8, qrSize - 3 + qrSize * 8, qrSize - 2 + qrSize * 8, qrSize - 1 + qrSize * 8,]\n    const versionId2 = [8 + qrSize * (qrSize - 1), 8 + qrSize * (qrSize - 2), 8 + qrSize * (qrSize - 3), 8 + qrSize * (qrSize - 4), 8 + qrSize * (qrSize - 5), 8 + qrSize * (qrSize - 6), 8 + qrSize * (qrSize - 7), null, null, null, null, null, null, null, null,]\n\n    for (const formatBits of formatBitsAry) {\n        const qrAryClone = [...qrAry];\n\n        versionId0.forEach((val, ind) => {\n            const id = val;\n            if (id !== null) {\n                qrAryClone[id] = Number(formatBits[ind]);\n            }\n        });\n        versionId1.forEach((val, ind) => {\n            const id = val;\n            if (id !== null) {\n                qrAryClone[id] = Number(formatBits[ind]);\n            }\n        });\n        versionId2.forEach((val, ind) => {\n            const id = val;\n            if (id !== null) {\n                qrAryClone[id] = Number(formatBits[ind]);\n            }\n        });\n\n        qrArysWithInfo.push(qrAryClone);\n    }\n}\n\nfunction getQrArysWithVersionInfo(qrSize, version, qrArysWithInfo) {\n    if (version < 7) return;\n    const versionBits = Version_Information_Table[version - 7].split(\"\").reverse();\n    const bitPlacmentPos1 = [];\n    const bitPlacmentPos2 = [];\n\n    for (let i = 0; i < 6; i++) {\n        bitPlacmentPos1.push( i + qrSize * (qrSize - 11), i + qrSize * (qrSize - 10), i + qrSize * (qrSize - 9) );\n    }\n\n    for (let i = 0; i < 6; i++) {\n        bitPlacmentPos2.push( qrSize - 11 + qrSize * i, qrSize - 10 + qrSize * i, qrSize - 9 + qrSize * i );\n    }\n\n    for (const qrAry of qrArysWithInfo) {\n\n        bitPlacmentPos1.forEach((val, ind) => {\n            const id = val;\n            if (id !== null) {\n                qrAry[id] = Number(versionBits[ind]);\n            }\n        });\n        bitPlacmentPos2.forEach((val, ind) => {\n            const id = val;\n            if (id !== null) {\n                qrAry[id] = Number(versionBits[ind]);\n            }\n        });\n    }\n\n}\n\nfunction getMaskedQrArys(qrArys, dataIds, qrSize) {\n    let mask = 0;\n    for (const qrAry of qrArys) {\n        for (const id of dataIds) {\n            const row = id % qrSize;\n            const column = Math.trunc(id / qrSize);\n\n            if (mask === 0 && (row + column) % 2 === 0) {\n                qrAry[id] = 1 ^ qrAry[id];\n            }\n            if (mask === 1 && (column) % 2 === 0) {\n                qrAry[id] = 1 ^ qrAry[id];\n            }\n            if (mask === 2 && (row) % 3 === 0) {\n                qrAry[id] = 1 ^ qrAry[id];\n            }\n            if (mask === 3 && (row + column) % 3 === 0) {\n                qrAry[id] = 1 ^ qrAry[id];\n            }\n            if (mask === 4 && ( Math.floor(column / 2) + Math.floor(row / 3) ) % 2 === 0) {\n                qrAry[id] = 1 ^ qrAry[id];\n            }\n            if (mask === 5 && ((row * column) % 2) + ((row * column) % 3) === 0) {\n                qrAry[id] = 1 ^ qrAry[id];\n            }\n            if (mask === 6 && ( ((row * column) % 2) + ((row * column) % 3) ) % 2 === 0) {\n                qrAry[id] = 1 ^ qrAry[id];\n            }\n            if (mask === 7 && ( ((row + column) % 2) + ((row * column) % 3) ) % 2 === 0) {\n                qrAry[id] = 1 ^ qrAry[id];\n            }\n        }\n        mask++;\n    }\n\n    return qrArys;\n}\n\nfunction getQrAryWithMinPenalty(maskedQrArys, qrSize) {\n    const penaltyAry = [];\n    \n    for (const qrAry of maskedQrArys) {\n        let penalty = 0;\n        const rows = [];\n        const cols = [];\n\n        // Penalty 1\n        for (let i = 0; i < qrSize; i++) {\n            const rowAry = qrAry.slice(qrSize * i, qrSize * (i + 1));\n            rows.push(rowAry);\n            penalty += calcPenalty1(rowAry);\n        }\n\n        for (let i = 0; i < qrSize; i++) {\n            const colAry = rows.map(rw => rw[i]);\n            cols.push(colAry);\n            penalty += calcPenalty1(colAry);\n        }\n\n        //Penalty 2\n        for (let i = 0; i < qrSize - 1; i++) {\n            for (let j = 0; j < qrSize - 1; j++) {\n                let sum = rows[i][j] + rows[i][j + 1] + rows[i + 1][j] + rows[i + 1][j + 1];\n                if (sum === 0 || sum === 4) penalty += 3; \n            }\n        }\n\n        //Penalty 3\n        const penalty3Patter = [\"10111010000\", \"00001011101\"];\n        for (let i = 0; i < qrSize; i++) {\n            for (let j = 0; j < qrSize - penalty3Patter[0].length; j++) {\n                const str = rows[i].slice(j, j + penalty3Patter[0].length).join(\"\");\n                if (str === penalty3Patter[0] || str === penalty3Patter[1]) penalty += 40;\n            }\n        }\n\n        for (let i = 0; i < qrSize; i++) {\n            for (let j = 0; j < qrSize - penalty3Patter[0].length; j++) {\n                const str = cols[i].slice(j, j + penalty3Patter[0].length).join(\"\");\n                if (str === penalty3Patter[0] || str === penalty3Patter[1]) penalty += 40;\n            }\n        }\n\n        // Penalty 4\n        const modulesLen = qrAry.length;\n        const darkModulesLen = qrAry.filter(bt => bt === 1).length;\n        const darkPerc = (darkModulesLen / modulesLen) * 100;\n        const roundedPercentage = darkPerc > 50\n                                    ? Math.floor(darkPerc / 5) * 5\n                                    : Math.ceil(darkPerc / 5) * 5;\n        const mixPenalty = Math.abs(roundedPercentage - 50) * 2;\n        penalty += mixPenalty;\n\n        penaltyAry.push(penalty);\n    }\n\n    const smallestVal = Math.min(...penaltyAry);\n    const ind = penaltyAry.indexOf(smallestVal);\n\n    return maskedQrArys[ind];\n}\n\nfunction calcPenalty1(rowAry) {\n    let penalty = 0;\n    let cnt = 0;\n    let bit = rowAry[0];\n    for (const bitVal of rowAry) {\n        if (bit === bitVal) cnt++;\n        else {\n            if (cnt >= 5) penalty += (cnt - 2);\n            cnt = 1;\n            bit = bitVal;\n        }\n    }\n\n    if (cnt >= 5) penalty += (cnt - 2);\n\n    return penalty;\n}","export const Error_Correction_Level = new Map([\n    [\"L\", 7],\n    [\"M\", 15],\n    [\"Q\", 25],\n    [\"H\", 30],\n]);\n\nexport const Mode_Indicator = new Map([\n    [\"numeric\", \"0001\"],\n    [\"alphanumeric\", \"0010\"],\n    [\"byte\", \"0100\"],\n]);\n\nexport const Character_Capacity_Table = {\n    numeric: {\n        L: [41, 77, 127, 187, 255, 322, 370, 461, 552, 652, 772, 883, 1022, 1101, 1250, 1408, 1548, 1725, 1903, 2061, 2232, 2409, 2620, 2812, 3057, 3283, 3517, 3669, 3909, 4158, 4417, 4686, 4965, 5253, 5529, 5836, 6153, 6479, 6743, 7089],\n        M: [34, 63, 101, 149, 202, 255, 293, 365, 432, 513, 604, 691, 796, 871, 991, 1082, 1212, 1346, 1500, 1600, 1708, 1872, 2059, 2188, 2395, 2544, 2701, 2857, 3035, 3289, 3486, 3693, 3909, 4134, 4343, 4588, 4775, 5039, 5313, 5596],\n        Q: [27, 48, 77, 111, 144, 178, 207, 259, 312, 364, 427, 489, 580, 621, 703, 775, 876, 948, 1063, 1159, 1224, 1358, 1468, 1588, 1718, 1804, 1933, 2085, 2181, 2358, 2473, 2670, 2805, 2949, 3081, 3244, 3417, 3599, 3791, 3993],\n        H: [17, 34, 58, 82, 106, 139, 154, 202, 235, 288, 331, 374, 427, 468, 530, 602, 674, 746, 813, 919, 969, 1056, 1108, 1228, 1286, 1425, 1501, 1581, 1677, 1782, 1897, 2022, 2157, 2301, 2361, 2524, 2625, 2735, 2927, 3057],\n    },\n    alphanumeric: {\n        L: [25, 47, 77, 114, 154, 195, 224, 279, 335, 395, 468, 535, 619, 667, 758, 854, 938, 1046, 1153, 1249, 1352, 1460, 1588, 1704, 1853, 1990, 2132, 2223, 2369, 2520, 2677, 2840, 3009, 3183, 3351, 3537, 3729, 3927, 4087, 4296],\n        M: [20, 38, 61, 90, 122, 154, 178, 221, 262, 311, 366, 419, 483, 528, 600, 656, 734, 816, 909, 970, 1035, 1134, 1248, 1326, 1451, 1542, 1637, 1732, 1839, 1994, 2113, 2238, 2369, 2506, 2632, 2780, 2894, 3054, 3220, 3391],\n        Q: [16, 29, 47, 67, 87, 108, 125, 157, 189, 221, 259, 296, 352, 376, 426, 470, 531, 574, 644, 702, 742, 823, 890, 963, 1041, 1094, 1172, 1263, 1322, 1429, 1499, 1618, 1700, 1787, 1867, 1966, 2071, 2181, 2298, 2420],\n        H: [10, 20, 35, 50, 64, 84, 93, 122, 143, 174, 200, 227, 259, 283, 321, 365, 408, 452, 493, 557, 587, 640, 672, 744, 779, 864, 910, 958, 1016, 1080, 1150, 1226, 1307, 1394, 1431, 1530, 1591, 1658, 1774, 1852],\n    },\n    byte: {\n        L: [17, 32, 53, 78, 106, 134, 154, 192, 230, 271, 321, 367, 425, 458, 520, 586, 644, 718, 792, 858, 929, 1003, 1091, 1171, 1273, 1367, 1465, 1528, 1628, 1732, 1840, 1952, 2068, 2188, 2303, 2431, 2563, 2699, 2809, 2953],\n        M: [14, 26, 42, 62, 84, 106, 122, 152, 180, 213, 251, 287, 331, 362, 412, 450, 504, 560, 624, 666, 711, 779, 857, 911, 997, 1059, 1125, 1190, 1264, 1370, 1452, 1538, 1628, 1722, 1809, 1911, 1989, 2099, 2213, 2331],\n        Q: [11, 20, 32, 46, 60, 74, 86, 108, 130, 151, 177, 203, 241, 258, 292, 322, 364, 394, 442, 482, 509, 565, 611, 661, 715, 751, 805, 868, 908, 982, 1030, 1112, 1168, 1228, 1283, 1351, 1423, 1499, 1579, 1663],\n        H: [7, 14, 24, 34, 44, 58, 64, 84, 98, 119, 137, 155, 177, 194, 220, 250, 280, 310, 338, 382, 403, 439, 461, 511, 535, 593, 625, 658, 698, 742, 790, 842, 898, 958, 983, 1051, 1093, 1139, 1219, 1273],\n    },\n};\n\nexport const Character_Count_Indicator = [\n    {numeric: 10, alphanumeric: 9, byte: 8},\n    {numeric: 12, alphanumeric: 11, byte: 16},\n    {numeric: 14, alphanumeric: 13, byte: 16},\n]\n\nexport const Alphanumeric_Code = new Map([\n    [\" \", 36],\n    [\"$\", 37],\n    [\"%\", 38],\n    [\"*\", 39],\n    [\"+\", 40],\n    [\"-\", 41],\n    [\".\", 42],\n    [\"/\", 43],\n    [\":\", 44],\n]);\nfor (let i = 0; i < 10; i++) {\n    Alphanumeric_Code.set(i.toString(), i);\n}\nfor (let i = 65; i <= 90; i++) {\n    Alphanumeric_Code.set(String.fromCharCode(i), i - 55);\n}\n\nexport const Error_Correction_Code_Table = {\n    L: [{dataCapacity:19,errorPerBlock:7,group1:[1,19],group2:[0,0]},{dataCapacity:34,errorPerBlock:10,group1:[1,34],group2:[0,0]},{dataCapacity:55,errorPerBlock:15,group1:[1,55],group2:[0,0]},{dataCapacity:80,errorPerBlock:20,group1:[1,80],group2:[0,0]},{dataCapacity:108,errorPerBlock:26,group1:[1,108],group2:[0,0]},{dataCapacity:136,errorPerBlock:18,group1:[2,68],group2:[0,0]},{dataCapacity:156,errorPerBlock:20,group1:[2,78],group2:[0,0]},{dataCapacity:194,errorPerBlock:24,group1:[2,97],group2:[0,0]},{dataCapacity:232,errorPerBlock:30,group1:[2,116],group2:[0,0]},{dataCapacity:274,errorPerBlock:18,group1:[2,68],group2:[2,69]},{dataCapacity:324,errorPerBlock:20,group1:[4,81],group2:[0,0]},{dataCapacity:370,errorPerBlock:24,group1:[2,92],group2:[2,93]},{dataCapacity:428,errorPerBlock:26,group1:[4,107],group2:[0,0]},{dataCapacity:461,errorPerBlock:30,group1:[3,115],group2:[1,116]},{dataCapacity:523,errorPerBlock:22,group1:[5,87],group2:[1,88]},{dataCapacity:589,errorPerBlock:24,group1:[5,98],group2:[1,99]},{dataCapacity:647,errorPerBlock:28,group1:[1,107],group2:[5,108]},{dataCapacity:721,errorPerBlock:30,group1:[5,120],group2:[1,121]},{dataCapacity:795,errorPerBlock:28,group1:[3,113],group2:[4,114]},{dataCapacity:861,errorPerBlock:28,group1:[3,107],group2:[5,108]},{dataCapacity:932,errorPerBlock:28,group1:[4,116],group2:[4,117]},{dataCapacity:1006,errorPerBlock:28,group1:[2,111],group2:[7,112]},{dataCapacity:1094,errorPerBlock:30,group1:[4,121],group2:[5,122]},{dataCapacity:1174,errorPerBlock:30,group1:[6,117],group2:[4,118]},{dataCapacity:1276,errorPerBlock:26,group1:[8,106],group2:[4,107]},{dataCapacity:1370,errorPerBlock:28,group1:[10,114],group2:[2,115]},{dataCapacity:1468,errorPerBlock:30,group1:[8,122],group2:[4,123]},{dataCapacity:1531,errorPerBlock:30,group1:[3,117],group2:[10,118]},{dataCapacity:1631,errorPerBlock:30,group1:[7,116],group2:[7,117]},{dataCapacity:1735,errorPerBlock:30,group1:[5,115],group2:[10,116]},{dataCapacity:1843,errorPerBlock:30,group1:[13,115],group2:[3,116]},{dataCapacity:1955,errorPerBlock:30,group1:[17,115],group2:[0,0]},{dataCapacity:2071,errorPerBlock:30,group1:[17,115],group2:[1,116]},{dataCapacity:2191,errorPerBlock:30,group1:[13,115],group2:[6,116]},{dataCapacity:2306,errorPerBlock:30,group1:[12,121],group2:[7,122]},{dataCapacity:2434,errorPerBlock:30,group1:[6,121],group2:[14,122]},{dataCapacity:2566,errorPerBlock:30,group1:[17,122],group2:[4,123]},{dataCapacity:2702,errorPerBlock:30,group1:[4,122],group2:[18,123]},{dataCapacity:2812,errorPerBlock:30,group1:[20,117],group2:[4,118]},{dataCapacity:2956,errorPerBlock:30,group1:[19,118],group2:[6,119]}],\n    M: [{dataCapacity:16,errorPerBlock:10,group1:[1,16],group2:[0,0]},{dataCapacity:28,errorPerBlock:16,group1:[1,28],group2:[0,0]},{dataCapacity:44,errorPerBlock:26,group1:[1,44],group2:[0,0]},{dataCapacity:64,errorPerBlock:18,group1:[2,32],group2:[0,0]},{dataCapacity:86,errorPerBlock:24,group1:[2,43],group2:[0,0]},{dataCapacity:108,errorPerBlock:16,group1:[4,27],group2:[0,0]},{dataCapacity:124,errorPerBlock:18,group1:[4,31],group2:[0,0]},{dataCapacity:154,errorPerBlock:22,group1:[2,38],group2:[2,39]},{dataCapacity:182,errorPerBlock:22,group1:[3,36],group2:[2,37]},{dataCapacity:216,errorPerBlock:26,group1:[4,43],group2:[1,44]},{dataCapacity:254,errorPerBlock:30,group1:[1,50],group2:[4,51]},{dataCapacity:290,errorPerBlock:22,group1:[6,36],group2:[2,37]},{dataCapacity:334,errorPerBlock:22,group1:[8,37],group2:[1,38]},{dataCapacity:365,errorPerBlock:24,group1:[4,40],group2:[5,41]},{dataCapacity:415,errorPerBlock:24,group1:[5,41],group2:[5,42]},{dataCapacity:453,errorPerBlock:28,group1:[7,45],group2:[3,46]},{dataCapacity:507,errorPerBlock:28,group1:[10,46],group2:[1,47]},{dataCapacity:563,errorPerBlock:26,group1:[9,43],group2:[4,44]},{dataCapacity:627,errorPerBlock:26,group1:[3,44],group2:[11,45]},{dataCapacity:669,errorPerBlock:26,group1:[3,41],group2:[13,42]},{dataCapacity:714,errorPerBlock:26,group1:[17,42],group2:[0,0]},{dataCapacity:782,errorPerBlock:28,group1:[17,46],group2:[0,0]},{dataCapacity:860,errorPerBlock:28,group1:[4,47],group2:[14,48]},{dataCapacity:914,errorPerBlock:28,group1:[6,45],group2:[14,46]},{dataCapacity:1000,errorPerBlock:28,group1:[8,47],group2:[13,48]},{dataCapacity:1062,errorPerBlock:28,group1:[19,46],group2:[4,47]},{dataCapacity:1128,errorPerBlock:28,group1:[22,45],group2:[3,46]},{dataCapacity:1193,errorPerBlock:28,group1:[3,45],group2:[23,46]},{dataCapacity:1267,errorPerBlock:28,group1:[21,45],group2:[7,46]},{dataCapacity:1373,errorPerBlock:28,group1:[19,47],group2:[10,48]},{dataCapacity:1455,errorPerBlock:28,group1:[2,46],group2:[29,47]},{dataCapacity:1541,errorPerBlock:28,group1:[10,46],group2:[23,47]},{dataCapacity:1631,errorPerBlock:28,group1:[14,46],group2:[21,47]},{dataCapacity:1725,errorPerBlock:28,group1:[14,46],group2:[23,47]},{dataCapacity:1812,errorPerBlock:28,group1:[12,47],group2:[26,48]},{dataCapacity:1914,errorPerBlock:28,group1:[6,47],group2:[34,48]},{dataCapacity:1992,errorPerBlock:28,group1:[29,46],group2:[14,47]},{dataCapacity:2102,errorPerBlock:28,group1:[13,46],group2:[32,47]},{dataCapacity:2216,errorPerBlock:28,group1:[40,47],group2:[7,48]},{dataCapacity:2334,errorPerBlock:28,group1:[18,47],group2:[31,48]}],\n    Q: [{dataCapacity:13,errorPerBlock:13,group1:[1,13],group2:[0,0]},{dataCapacity:22,errorPerBlock:22,group1:[1,22],group2:[0,0]},{dataCapacity:34,errorPerBlock:18,group1:[2,17],group2:[0,0]},{dataCapacity:48,errorPerBlock:26,group1:[2,24],group2:[0,0]},{dataCapacity:62,errorPerBlock:18,group1:[2,15],group2:[2,16]},{dataCapacity:76,errorPerBlock:24,group1:[4,19],group2:[0,0]},{dataCapacity:88,errorPerBlock:18,group1:[2,14],group2:[4,15]},{dataCapacity:110,errorPerBlock:22,group1:[4,18],group2:[2,19]},{dataCapacity:132,errorPerBlock:20,group1:[4,16],group2:[4,17]},{dataCapacity:154,errorPerBlock:24,group1:[6,19],group2:[2,20]},{dataCapacity:180,errorPerBlock:28,group1:[4,22],group2:[4,23]},{dataCapacity:206,errorPerBlock:26,group1:[4,20],group2:[6,21]},{dataCapacity:244,errorPerBlock:24,group1:[8,20],group2:[4,21]},{dataCapacity:261,errorPerBlock:20,group1:[11,16],group2:[5,17]},{dataCapacity:295,errorPerBlock:30,group1:[5,24],group2:[7,25]},{dataCapacity:325,errorPerBlock:24,group1:[15,19],group2:[2,20]},{dataCapacity:367,errorPerBlock:28,group1:[1,22],group2:[15,23]},{dataCapacity:397,errorPerBlock:28,group1:[17,22],group2:[1,23]},{dataCapacity:445,errorPerBlock:26,group1:[17,21],group2:[4,22]},{dataCapacity:485,errorPerBlock:30,group1:[15,24],group2:[5,25]},{dataCapacity:512,errorPerBlock:28,group1:[17,22],group2:[6,23]},{dataCapacity:568,errorPerBlock:30,group1:[7,24],group2:[16,25]},{dataCapacity:614,errorPerBlock:30,group1:[11,24],group2:[14,25]},{dataCapacity:664,errorPerBlock:30,group1:[11,24],group2:[16,25]},{dataCapacity:718,errorPerBlock:30,group1:[7,24],group2:[22,25]},{dataCapacity:754,errorPerBlock:28,group1:[28,22],group2:[6,23]},{dataCapacity:808,errorPerBlock:30,group1:[8,23],group2:[26,24]},{dataCapacity:871,errorPerBlock:30,group1:[4,24],group2:[31,25]},{dataCapacity:911,errorPerBlock:30,group1:[1,23],group2:[37,24]},{dataCapacity:985,errorPerBlock:30,group1:[15,24],group2:[25,25]},{dataCapacity:1033,errorPerBlock:30,group1:[42,24],group2:[1,25]},{dataCapacity:1115,errorPerBlock:30,group1:[10,24],group2:[35,25]},{dataCapacity:1171,errorPerBlock:30,group1:[29,24],group2:[19,25]},{dataCapacity:1231,errorPerBlock:30,group1:[44,24],group2:[7,25]},{dataCapacity:1286,errorPerBlock:30,group1:[39,24],group2:[14,25]},{dataCapacity:1354,errorPerBlock:30,group1:[46,24],group2:[10,25]},{dataCapacity:1426,errorPerBlock:30,group1:[49,24],group2:[10,25]},{dataCapacity:1502,errorPerBlock:30,group1:[48,24],group2:[14,25]},{dataCapacity:1582,errorPerBlock:30,group1:[43,24],group2:[22,25]},{dataCapacity:1666,errorPerBlock:30,group1:[34,24],group2:[34,25]}],\n    H: [{dataCapacity:9,errorPerBlock:17,group1:[1,9],group2:[0,0]},{dataCapacity:16,errorPerBlock:28,group1:[1,16],group2:[0,0]},{dataCapacity:26,errorPerBlock:22,group1:[2,13],group2:[0,0]},{dataCapacity:36,errorPerBlock:16,group1:[4,9],group2:[0,0]},{dataCapacity:46,errorPerBlock:22,group1:[2,11],group2:[2,12]},{dataCapacity:60,errorPerBlock:28,group1:[4,15],group2:[0,0]},{dataCapacity:66,errorPerBlock:26,group1:[4,13],group2:[1,14]},{dataCapacity:86,errorPerBlock:26,group1:[4,14],group2:[2,15]},{dataCapacity:100,errorPerBlock:24,group1:[4,12],group2:[4,13]},{dataCapacity:122,errorPerBlock:28,group1:[6,15],group2:[2,16]},{dataCapacity:140,errorPerBlock:24,group1:[3,12],group2:[8,13]},{dataCapacity:158,errorPerBlock:28,group1:[7,14],group2:[4,15]},{dataCapacity:180,errorPerBlock:22,group1:[12,11],group2:[4,12]},{dataCapacity:197,errorPerBlock:24,group1:[11,12],group2:[5,13]},{dataCapacity:223,errorPerBlock:24,group1:[11,12],group2:[7,13]},{dataCapacity:253,errorPerBlock:30,group1:[3,15],group2:[13,16]},{dataCapacity:283,errorPerBlock:28,group1:[2,14],group2:[17,15]},{dataCapacity:313,errorPerBlock:28,group1:[2,14],group2:[19,15]},{dataCapacity:341,errorPerBlock:26,group1:[9,13],group2:[16,14]},{dataCapacity:385,errorPerBlock:28,group1:[15,15],group2:[10,16]},{dataCapacity:406,errorPerBlock:30,group1:[19,16],group2:[6,17]},{dataCapacity:442,errorPerBlock:24,group1:[34,13],group2:[0,0]},{dataCapacity:464,errorPerBlock:30,group1:[16,15],group2:[14,16]},{dataCapacity:514,errorPerBlock:30,group1:[30,16],group2:[2,17]},{dataCapacity:538,errorPerBlock:30,group1:[22,15],group2:[13,16]},{dataCapacity:596,errorPerBlock:30,group1:[33,16],group2:[4,17]},{dataCapacity:628,errorPerBlock:30,group1:[12,15],group2:[28,16]},{dataCapacity:661,errorPerBlock:30,group1:[11,15],group2:[31,16]},{dataCapacity:701,errorPerBlock:30,group1:[19,15],group2:[26,16]},{dataCapacity:745,errorPerBlock:30,group1:[23,15],group2:[25,16]},{dataCapacity:793,errorPerBlock:30,group1:[23,15],group2:[28,16]},{dataCapacity:845,errorPerBlock:30,group1:[19,15],group2:[35,16]},{dataCapacity:901,errorPerBlock:30,group1:[11,15],group2:[46,16]},{dataCapacity:961,errorPerBlock:30,group1:[59,16],group2:[1,17]},{dataCapacity:986,errorPerBlock:30,group1:[22,15],group2:[41,16]},{dataCapacity:1054,errorPerBlock:30,group1:[2,15],group2:[64,16]},{dataCapacity:1096,errorPerBlock:30,group1:[24,15],group2:[46,16]},{dataCapacity:1142,errorPerBlock:30,group1:[42,15],group2:[32,16]},{dataCapacity:1222,errorPerBlock:30,group1:[10,15],group2:[67,16]},{dataCapacity:1276,errorPerBlock:30,group1:[20,15],group2:[61,16]}],\n}\n\nexport const Galois_Field_Table = [\n    //{exp: , int: }\n]\nfunction calcPowTwo(int = 0.5, exp = 0) {\n    if (exp > 255) return;\n    int *= 2;\n    int = int > 255 ? int ^ 285 : int;\n    Galois_Field_Table.push({exp , int});\n    return calcPowTwo(int, exp + 1);\n}\ncalcPowTwo();\n\nexport const Remainder_Bits = [0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0];\n\nexport const Alignment_Pattern_Locations_Table = [[0],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]]\n\nexport const Format_Information_Table = {\n    L: ['111011111000100', '111001011110011', '111110110101010', '111100010011101', '110011000101111', '110001100011000', '110110001000001', '110100101110110'],\n    M: ['101010000010010', '101000100100101', '101111001111100', '101101101001011', '100010111111001', '100000011001110', '100111110010111', '100101010100000'],\n    Q: ['011010101011111', '011000001101000', '011111100110001', '011101000000110', '010010010110100', '010000110000011', '010111011011010', '010101111101101'],\n    H: ['001011010001001', '001001110111110', '001110011100111', '001100111010000', '000011101100010', '000001001010101', '000110100001100', '000100000111011'],\n}\n\nexport const Version_Information_Table = ['000111110010010100', '001000010110111100', '001001101010011001', '001010010011010011', '001011101111110110', '001100011101100010', '001101100001000111', '001110011000001101', '001111100100101000', '010000101101111000', '010001010001011101', '010010101000010111', '010011010100110010', '010100100110100110', '010101011010000011', '010110100011001001', '010111011111101100', '011000111011000100', '011001000111100001', '011010111110101011', '011011000010001110', '011100110000011010', '011101001100111111', '011110110101110101', '011111001001010000', '100000100111010101', '100001011011110000', '100010100010111010', '100011011110011111', '100100101100001011', '100101010000101110', '100110101001100100', '100111010101000001', '101000110001101001']","import { qrEncodedData, getFinalQrAry } from \"./encoding-service\";\nimport {Alignment_Pattern_Locations_Table} from \"./encoding-structure\";\n\nconst svgns = \"http://www.w3.org/2000/svg\";\n\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n    <style>\n        svg {\n            border: solid 1px rgba(0, 0, 0, 0.2);\n            border-radius: 10px;\n        }\n    </style>\n    <svg xmlns=\"${svgns}\"></svg>\n`\n\nclass DamiQrcode extends HTMLElement {\n    constructor() {\n        super();\n        this.initShadow();\n\n        this.xyPadding = 10;\n        this.qrSize;\n        this.dataIds = [];\n\n        this.size = 300;\n        this.color = \"black\";\n        this.background = \"white\";\n        this.errorCorrection = \"L\";\n        this.value = \"\";\n    }\n\n    initShadow() {\n        const shadow = this.attachShadow({mode: \"open\"});\n        shadow.append(template.content.cloneNode(true));\n        this.svgElm = shadow.querySelector(\"svg\");\n    }\n\n    initSvgSize() {\n        const width = this.getAttribute(\"size\") ? Number(this.getAttribute(\"size\")) : this.size;\n\n        if (typeof width === \"number\") {\n            this.svgElm.setAttribute(\"width\", width);\n            this.svgElm.setAttribute(\"height\", width);\n        } else {\n            console.error(\"Enter both width and height and all numbers.\");\n        }\n    }\n\n    connectedCallback() {\n        const value = this.getAttribute(\"value\") ? this.getAttribute(\"value\") : this.value;\n        const errorCorrection = this.getAttribute(\"errorCorrection\") ? this.getAttribute(\"errorCorrection\") : this.errorCorrection;\n        const color = this.getAttribute(\"color\") ? this.getAttribute(\"color\") : this.color;\n        const background = this.getAttribute(\"background\") ? this.getAttribute(\"background\") : this.background;\n\n        this.svgElm.style.background = background;\n\n        this.initSvgSize();\n\n        const {data, version} = qrEncodedData(value, errorCorrection);\n\n        this.initQr(version);\n\n        this.addFinderPatternWithSeparator();\n\n        this.addAlignmentPatterns(version);\n\n        this.addTimingPatterns();\n\n        this.addDarkModule(version);\n\n        const formatInfoIds = this.reserveFormatInformationArea();\n        const versionInfoIds =this.reserveVersionInformationArea(version);\n        const reservedIds = [...formatInfoIds, ...versionInfoIds];\n\n        this.placeDataBits(data, reservedIds);\n\n        const dataMap = this.qrDataMap();\n\n        const testAry = getFinalQrAry(dataMap, this.qrSize, this.dataIds, errorCorrection, version);\n\n        for (let i = 0; i < this.qrSize * this.qrSize; i++) {\n            this.svgElm.getElementById(i).setAttribute(\"fill\",testAry[i] === 1 ? color : background);\n        }\n    }\n\n    static get observedAttributes() {\n        return [];\n    }\n    \n    attributeChangedCallback(name, oldValue, newValue) {\n        \n    }\n\n    initQr(version) {\n        const qrSize = ((version - 1) * 4) + 21;\n        this.qrSize = qrSize;\n\n        const [startX, startY] = this.getRectStartPos();\n        const [width, height] = this.getRectDimentions(qrSize);\n\n        for (let i = 0; i < qrSize; i++) {\n            for (let j = 0; j < qrSize; j++) {\n                const rect = this.initRectWithSize(startX + width * j, startY + height * i, width, height, i * qrSize + j);\n                this.svgElm.appendChild(rect);\n            }\n        }\n    }\n\n    qrDataMap() {\n        const dataMap = [];\n        for (let id = 0; id < this.qrSize * this.qrSize; id++) {\n            let bit;\n            if (this.svgElm.getElementById(id).getAttribute(\"fill\") === \"black\") bit = 1;\n            else if (this.svgElm.getElementById(id).getAttribute(\"fill\") === \"white\") bit = 0;\n            else bit = -1;\n\n            dataMap.push(bit);\n        }\n\n        return dataMap;\n    }\n\n    placeDataBits(data, reservedIds) {\n        let x = this.qrSize - 1;\n        let y = this.qrSize - 1;\n\n        let left = true;\n        let up = true;\n\n        while (data.length > 0) {\n            const id = x + (y * this.qrSize);\n\n            const occupied = this.svgElm.getElementById(id).getAttribute(\"fill\") !== \"grey\" || reservedIds.includes(id);\n            if (!occupied) {\n                const bit = data[0];\n                data = data.slice(1);\n\n                const color = bit === \"1\" ? \"black\" : \"white\";\n                this.svgElm.getElementById(id).setAttribute(\"fill\", color);\n                this.dataIds.push(id);\n            }\n\n            if (left) {\n                x--;\n            } else {\n                x++;\n                up ? y-- : y++; \n            }\n            left = !left;\n\n            if (up && y < 0) {\n                up = false;\n                y = 0;\n                x = x - 2;\n            }\n            if (!up && y > this.qrSize - 1) {\n                up = true;\n                y = this.qrSize - 1;\n                x = x - 2;\n            }\n\n            if (id === 7) x--;\n        }\n    }\n\n    reserveVersionInformationArea(version) {\n        if (version < 7) return [];\n\n        const qrSize = this.qrSize;\n\n        const pattern1 = [63, 63, 63].map(int => int.toString(2).split(\"\"));\n        const idAry1 = this.squarePatternMaker(0, qrSize - 11, pattern1, qrSize, false);\n\n        const pattern2 = [7, 7, 7, 7, 7, 7].map(int => int.toString(2).split(\"\"));\n        const idAry2 = this.squarePatternMaker(qrSize - 11, 0, pattern2, qrSize, false);\n\n        return [...idAry1, ...idAry2];\n    }\n\n    reserveFormatInformationArea() {\n        const posAry = [[0,8,\"H\", 9],[8,0,\"V\", 8],[this.qrSize -8, 8, \"H\", 8],[8, this.qrSize - 8, \"V\", 8]];\n        const ids = [];\n\n        for (const ary of posAry) {\n            if (ary[2] === \"H\") {\n                for (let i = 0; i < ary[3]; i++) {\n                    const id = ary[0] + i + (ary[1] * this.qrSize);\n                    const rect = this.svgElm.getElementById(id);\n                    rect.getAttribute(\"fill\") === \"grey\" ? ids.push(id) : null;\n                }\n            } else {\n                for (let i = 0; i < ary[3]; i++) {\n                    const id = ary[0] + ((ary[1] + i) * this.qrSize);\n                    const rect = this.svgElm.getElementById(id);\n                    rect.getAttribute(\"fill\") === \"grey\" ? ids.push(id) : null;\n                }\n            }\n        }\n\n        return ids;\n    }\n\n    \n\n    addDarkModule(version) {\n        const xPos = 8;\n        const yPos = (4 * version) + 9;\n\n        const id = xPos + (yPos * this.qrSize);\n\n        this.svgElm.getElementById(id).setAttribute(\"fill\", \"black\");\n    }\n\n    addTimingPatterns() {\n        for (let i = 8; i < this.qrSize - 8; i++) {\n            const id1 = i + (6 * this.qrSize);\n            const id2 = 6 + (i * this.qrSize);\n\n            const color = i % 2 === 0 ? \"black\" : \"white\";\n\n            this.svgElm.getElementById(id1).setAttribute(\"fill\", color);\n            this.svgElm.getElementById(id2).setAttribute(\"fill\", color);\n        }\n    }\n\n    addAlignmentPatterns(version) {\n        const alignPos = Alignment_Pattern_Locations_Table[version - 1];\n        if (alignPos.length < 2) return;\n\n        const allPos = this.getEveryAlignmentPos(alignPos);\n        const notOverlappingPos = allPos.filter(pos => {\n            const id = pos[0] + pos[1] * this.qrSize;\n            const color = this.svgElm.getElementById(id).getAttribute(\"fill\");\n            return color === \"grey\";\n        });\n\n        const qrSize = this.qrSize;\n        const pattern = [31, 17, 21, 17, 31].map(int => int.toString(2).split(\"\"));\n\n        notOverlappingPos.forEach(pos => {\n            this.squarePatternMaker(pos[0] - 2, pos[1] - 2, pattern, qrSize);\n        });\n    }\n\n    getEveryAlignmentPos(alignPos) {\n        const posAry = [];\n        for (const posX of alignPos) {\n            for (const posY of alignPos) {\n                posAry.push([posX, posY]);\n            }\n        }\n\n        return posAry;\n    }\n\n    addSeperators(startX, startY, right, bottom, qrSize) {\n        const stepX = right ? 1 : -1;\n        const stepY = bottom ? 1 : -1;\n\n        for (let i = 0; i < 8; i++) {\n            const id1 = startX + (i * stepX) + (startY * qrSize);\n            const id2 = (startX + (7 * stepX) + (startY * qrSize)) + (i * stepY * qrSize);\n\n            const rect1 = this.svgElm.getElementById(id1);\n            rect1.setAttribute(\"fill\", \"white\");\n\n            const rect2 = this.svgElm.getElementById(id2);\n            rect2.setAttribute(\"fill\", \"white\");\n\n        }\n    }\n\n    addFinderPatternWithSeparator() {\n        const qrSize = this.qrSize;\n        const pattern = [127, 65, 93, 93, 93, 65, 127].map(int => int.toString(2).split(\"\"));\n\n        this.squarePatternMaker(0,0, pattern, qrSize);\n        this.addSeperators(0, 7, true, false, qrSize);\n\n        this.squarePatternMaker(qrSize - 7,0, pattern, qrSize);\n        this.addSeperators(qrSize - 1, 7, false, false, qrSize);\n\n        this.squarePatternMaker(0, qrSize - 7, pattern, qrSize);\n        this.addSeperators(0, qrSize - 8, true, true, qrSize);\n    }\n\n    squarePatternMaker(startX, startY, pattern, qrSize, fillColor = true) {\n        const idAry = [];\n        for (let i = startY; i < startY + pattern.length; i++) {\n            for (let j = startX; j < startX + pattern[i - startY].length; j++) {\n                const id = i * qrSize + j;\n                idAry.push(id);\n                const rect = this.svgElm.getElementById(id);\n                const color = pattern[i - startY][j - startX] === \"1\" ? \"black\" : \"white\";\n\n                fillColor ? rect.setAttribute(\"fill\", color) : null;\n            }\n        }\n\n        return idAry;\n    }\n\n    initRectWithSize(x, y, width, height, id) {\n        const rectElm = document.createElementNS(svgns, \"rect\");\n\n        rectElm.setAttribute(\"id\", id);\n\n        rectElm.setAttribute(\"width\", width);\n        rectElm.setAttribute(\"height\", height);\n\n        rectElm.setAttribute(\"x\", x);\n        rectElm.setAttribute(\"y\", y);\n        \n        rectElm.setAttribute(\"fill\", \"grey\");\n\n        return rectElm;\n    }\n\n    getRectDimentions(noOfRect) {\n        const xPaddingPct = this.xyPadding * 2;\n        const yPaddingPct = this.xyPadding * 2;\n    \n        const svgDimentions = this.getSvgDimentions();\n    \n        if (!svgDimentions) return;\n    \n        const contWidth = ( (100 - xPaddingPct) * svgDimentions[0] ) / 100;\n        const contHeight = ( (100 - yPaddingPct) * svgDimentions[1] ) / 100;\n    \n        return [contWidth / noOfRect, contHeight / noOfRect];\n    }\n\n    getSvgDimentions() {\n        const width = this.svgElm?.clientWidth;\n        const height = this.svgElm?.clientHeight;\n    \n        if (width === undefined || height === undefined) return;\n        return [width, height];\n    }\n\n    getRectStartPos() {\n        const svgDimentions = this.getSvgDimentions();\n    \n        if (!svgDimentions) return;\n    \n        return [( this.xyPadding * svgDimentions[0] / 100),\n                ( this.xyPadding * svgDimentions[1] ) / 100];\n    }\n\n}\n\ncustomElements.define(\"dami-qrcode\", DamiQrcode);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import './barcode/barcode';\nimport './qrcode/qrcode';"],"names":[],"sourceRoot":""}